drop upbndntrON0;
drop lobndntrON0;
drop upbndtrON0;
drop lobndtrON0;
drop upbndgenON0;
drop lobndgenON0;
drop upxha0;
drop loxha0;
drop upbndgenstartup0;
drop lobndgenstartup0;
drop upbndgenshutdown0;
drop lobndgenshutdown0;

# To scale objective
suffix objscalefactor IN;
let ourobjective.objscalefactor := 1e-3;

# Perform initial solve
solve;
#solve > /dev/null; # use this to re-direct ampl output to null device

#display ourobjective.feaserror;

# Round and fix all integer variables

# display before values of possibly relaxed integer variables
#display xstf0;
#display binxstf0;
#display xha0;
#display ntrON0;
#display trON0;
#display genon0;
#display genstartup0;
#display genshutdown0;

#display trexceed;
#display PBalanceat0.lb, PBalanceat0.body, PBalanceat0.ub;
#display QBalanceat0.lb, QBalanceat0.body, QBalanceat0.ub;
#display Scostcblock;
#display Strblock;
#display LineCurrentTR;
#display LineCurrentTR.lb, LineCurrentTR.body, LineCurrentTR.ub;
#display relaxStr;
#display totalStr.lb, totalStr.body, totalStr.ub;

# Transformer tap settings
for {i in 1..TRcnt_original} {
    let xstf0[i] := round( max(min(xstf0[i],maxxstf[i]),minxstf[i]) );
    for {m in minxstf[i]..maxxstf[i]} {
    	if xstf0[i] == m then {
	   let binxstf0[i,m] := 1;
	}
	else {
           let binxstf0[i,m] := 0;
	}
    }
}
fix {i in 1..TRcnt_original} xstf0[i];
fix {i in 1..TRcnt_original, m in minxstf[i]..maxxstf[i]} binxstf0[i,m];

# Switched shunt susceptance
for {h in 1..SWSHcnt, a in 1..bhasize[h]: swshactive[h]*nha[h,a]>0} {
    let xha0[h,a] := round( max(min(xha0[h,a],nha[h,a]),0) );
}
fix {h in 1..SWSHcnt, a in 1..bhasize[h]: swshactive[h]*nha[h,a]>0} xha0[h,a];

# Line switch
#for {i in 1..NTRcnt_original} {
#    let ntrON0[i] := round(ntrON0[i]);
#}
#fix {i in 1..NTRcnt_original} ntrON0[i];
fix {i in 1..NTRcnt_original} ntrON0[i] := round( max(min(ntrON0[i],1),0) );

# Transformer switch
fix {i in 1..TRcnt_original} trON0[i] := round( max(min(trON0[i],1),0) );

# Generator commitment decision variables
for {g in 1..G} {
    if genon0[g] < 0.5 then {
       let genon0[g] := 0;
       if genonexist[g] > 0 then {
          let genstartup0[g] := 0;
          if (gensdqual[g] > 0) then {
	     # shutdown if qualified
	     let genshutdown0[g] := 1;
	  }
	  else {
	     # not permitted to shut down, so leave on
	     let genon0[g] := 1;
	     let genshutdown0[g] := 0;
	  }
       }
       else {
          let genstartup0[g] := 0;
	  let genshutdown0[g] := 0;
       }
    }
    else {
       let genon0[g] := 1;
       if genonexist[g] > 0 then {
       	  let genstartup0[g] := 0;
	  let genshutdown0[g] := 0;
       }
       else {
	  let genshutdown0[g] := 0;
          if (gensuqual[g] > 0) then {
             # startup if qualified
             let genstartup0[g] := 1;
	  } else {
	     # not permitted to startup, so leave off
	     let genon0[g] := 0;
	     let genstartup0[g] := 0;
	  }
       }
    }
}
fix {g in 1..G} genon0[g];
fix {g in 1..G} genstartup0[g];
fix {g in 1..G} genshutdown0[g];

# display after values of rounded and fixed integer variables
option omit_zero_rows 0;
option omit_zero_cols 0;
#display xstf0;
#display binxstf0;
#display xha0;
#display ntrON0;
#display trON0;
#display genon0;
#display genstartup0;
#display genshutdown0;

# The re-solve is done back at the Python level so we can first get some timing information
# and have the option of performing some other tasks before the re-solve

# Set options for re-solve
# TBD: Set maxtime!
#option knitro_options "outlev=4 outmode=2 outname='knitro-fixed.log' debug=0 feastol=1e-5 feastol_abs=9e-5 ftol=1e-6 scale=0 honorbnds=1 cg_maxit=50 bar_murule=0 bar_feasible=1 presolve=0 bar_refinement=1 bar_maxcrossit=1 bar_initpi_mpec=0.0 maxit=3000 alg=1 strat_warm_start=0 bar_initpt=2 bar_initmu=1e-6 bar_slackboundpush=1e-6 infeastol=1e-5 opttol=1.0e-3";

# ...and re-solve
#solve;

#display ourobjective.feaserror;

# tbd: check feasibility - if not feasible take some action
